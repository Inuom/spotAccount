# Project Context

## Purpose

**Shared Subscription Debt Manager** is a full-stack web application designed to manage shared subscription costs among small groups (5-20 users per subscription, up to 100 total users). The system automates debt tracking, share calculations, and payment verification workflows to help groups fairly distribute recurring subscription expenses.

**Key Goals**:
- Enable administrators to configure shared subscriptions with billing schedules
- Automatically calculate participant shares for each billing period
- Provide payment verification workflow for administrators
- Allow users to manage their own pending payments
- Generate balance reports and financial summaries
- Maintain data integrity and security for financial operations

## Tech Stack

### Backend
- **Framework**: NestJS 11+ with TypeScript
- **Runtime**: Node.js 18+ (Alpine Linux in Docker)
- **Database**: PostgreSQL 15 (via Prisma ORM 6+)
- **Authentication**: JWT (passport-jwt), bcrypt for password hashing
- **Validation**: class-validator, class-transformer
- **Testing**: Jest 30+ with ts-jest
- **API**: RESTful API with Express

### Frontend
- **Framework**: Angular 17+ with TypeScript
- **State Management**: NgRx 17+ (Store, Effects, Entity)
- **Testing**: Jasmine/Karma for unit tests, Cypress 15+ for E2E
- **Build**: Angular CLI with TypeScript 5.2+

### Infrastructure & DevOps
- **Infrastructure as Code**: Terraform for AWS provisioning
- **Containerization**: Docker with multi-stage builds
- **Orchestration**: Docker Compose for local development
- **Cloud Platform**: AWS
  - **Compute**: ECS Fargate (backend)
  - **Storage**: S3 + CloudFront (frontend static hosting)
  - **Database**: RDS PostgreSQL (production)
  - **Networking**: VPC, Security Groups, CloudFront CDN
- **CI/CD**: GitHub Actions
- **Monitoring**: CloudWatch Logs, application-level logging

### Development Tools
- **Database ORM**: Prisma with migrations
- **Package Manager**: npm
- **Code Quality**: ESLint (backend), Angular ESLint (frontend)
- **Type Checking**: TypeScript strict mode (frontend), relaxed (backend)

## Project Conventions

### Code Style

**TypeScript Configuration**:
- **Frontend**: Strict mode enabled (`strict: true`, `noImplicitReturns`, `noFallthroughCasesInSwitch`)
- **Backend**: Relaxed strict mode (`strictNullChecks: false`, `noImplicitAny: false`) for faster development
- **Target**: ES2022 (frontend), ES2021 (backend)
- **Module System**: ES2022 modules (frontend), CommonJS (backend)

**Naming Conventions**:
- **Files**: kebab-case for components/services (`user-list.component.ts`)
- **Classes**: PascalCase (`UserService`, `SubscriptionController`)
- **Variables/Functions**: camelCase (`getUserById`, `subscriptionData`)
- **Constants**: UPPER_SNAKE_CASE (`JWT_SECRET`, `MAX_USERS_PER_SUBSCRIPTION`)
- **Interfaces/Types**: PascalCase with descriptive names (`PaymentStatus`, `ChargeShare`)

**File Organization**:
- Feature-based module structure
- Separate files for components, services, models, guards, interceptors
- Component templates in dedicated HTML files (not inline)
- Shared utilities in `common/` directory

**Code Quality**:
- ESLint configured for backend TypeScript
- Angular ESLint for frontend
- All lint checks must pass in CI before merge

### Architecture Patterns

**Backend (NestJS)**:
- **Module-based architecture**: Feature modules (auth, users, subscriptions, charges, payments, reports)
- **Dependency Injection**: Constructor-based DI throughout
- **Guards**: JWT authentication guard, role-based authorization guard
- **Interceptors**: Global error handling, logging, response transformation
- **DTOs**: Data Transfer Objects with class-validator decorators
- **Services**: Business logic in service classes, controllers handle HTTP concerns
- **Database**: Prisma ORM with migrations, seed scripts for initial data

**Frontend (Angular + NgRx)**:
- **Feature-based modules**: Each feature has its own NgRx store module
- **State Management**: NgRx with normalized state using `@ngrx/entity`
- **Smart/Dumb Components**: 
  - Smart components: Container components that connect to store via selectors
  - Dumb components: Presentational components that receive data via `@Input()`
- **Effects Pattern**: All HTTP calls handled by NgRx Effects, actions generated by selectors
- **Selectors**: Business viewmodels computed from normalized store state
- **No State Persistence**: NgRx state recreated on page refresh for security (no localStorage persistence)
- **Global State**: Error and loading state managed globally in store with selectors for UI
- **Services**: HTTP services called only from Effects, not directly from components

**Data Flow**:
1. User action → Component dispatches action
2. Effect intercepts action → Calls HTTP service
3. Service returns data → Effect dispatches success/failure action
4. Reducer updates store → Selectors recompute viewmodels
5. Components subscribe to selectors → UI updates

**Future Migration**: Plan for Angular 18+ signals migration after core functionality is stable.

### Testing Strategy

**Coverage Requirements**:
- **Minimum 80% test coverage** across unit, integration, and E2E tests
- Coverage checked in CI/CD pipeline, failing pipelines block merges

**Backend Testing**:
- **Unit Tests**: Jest for services, controllers, guards, utilities
- **Integration Tests**: End-to-end API testing for critical flows (auth, subscriptions/charges, payments)
- **Test Structure**: `tests/` directory with `unit/`, `integration/`, `e2e/` subdirectories
- **Test Commands**: `npm test`, `npm run test:watch`, `npm run test:cov`

**Frontend Testing**:
- **Unit Tests**: Jasmine/Karma for components, services, selectors, reducers, effects
- **E2E Tests**: Cypress for critical user flows (login, subscription creation, payment creation, verification)
- **Test Structure**: `tests/` directory with `unit/`, `e2e/` subdirectories
- **Test Commands**: `npm test`, `npm run test:ci` (headless), `npm run e2e`

**Testing Approach**:
- Test-driven development (TDD) encouraged
- Critical paths must have integration/E2E tests
- Mock external dependencies (database, HTTP) in unit tests
- Use real database in integration tests

### Git Workflow

**Branching Strategy**:
- **Main branch**: `master` (production-ready code)
- **Feature branches**: `###-feature-name` (e.g., `001-shared-subscription-spec`, `002-cicd-aws-terraform`)
- Feature branches created from `master` and merged back via pull requests

**Pull Request Process**:
- All changes via pull request (no direct commits to master)
- Require at least one approval (Product Owner or Tech Lead)
- PR must include:
  - Problem statement and approach
  - Acceptance criteria
  - Spec deltas for governance-impacting changes
- CI/CD pipeline must pass (lint, tests, coverage) before merge

**Commit Conventions**:
- Clear, descriptive commit messages
- Link issues/tasks in PR descriptions
- Record decisions in spec or PR description

## Domain Context

### Core Entities

**User**: System participants with roles (ADMIN or USER)
- Administrators: Full access, payment verification, user/subscription management
- Users: Limited access, own payments and balances only

**Subscription**: Recurring shared expense configuration
- Contains: title, total monthly amount, billing day (1-31), frequency, owner, start/end dates
- Links to participants via `SubscriptionParticipant` junction table

**SubscriptionParticipant**: Links users to subscriptions with share calculation rules
- Share types: EQUAL (equal split) or CUSTOM (specified amount/percentage)
- When new participants added, all equal shares recalculated for future charges only

**Charge**: Monthly billing instance generated from subscription
- Contains: period start/end, total amount, status (PENDING, GENERATED, CANCELLED)
- Automatically generates `ChargeShare` records for each participant

**ChargeShare**: Individual participant's portion of a charge
- Contains: amount_due (calculated), amount_paid (from verified payments), status (OPEN, SETTLED)
- Status auto-computed: OPEN if amount_due > amount_paid, SETTLED otherwise

**Payment**: User payment record with verification workflow
- Status lifecycle: PENDING → VERIFIED (immutable) or CANCELLED
- Users can create/modify/delete own pending payments
- Administrators verify payments (makes them immutable)
- Verified payments affect charge share balances

### Business Rules

**Share Calculation**:
- Sum of all `ChargeShare.amount_due` must exactly equal `Charge.amount_total`
- Equal shares: total divided by active participant count
- Custom shares: specified amount/percentage per participant
- Rounding handled fairly to ensure totals match

**Payment Verification**:
- Only administrators can verify payments
- Verified payments are immutable (no edits/deletes)
- Verification updates related charge share `amount_paid`
- Payment can reference a specific charge (optional)

**Participant Management**:
- Adding new participants to existing subscription:
  - Recalculates all equal shares for future charges
  - Historical charges remain unchanged
  - Prevents duplicate participants (unique constraint)

**Data Integrity**:
- Monetary amounts: positive decimals with appropriate precision
- Date validation: period_start < period_end
- User access: Users can only modify own pending payments
- Financial data: All monetary operations logged with user context

### Authentication & Authorization

**Authentication**:
- Username/password authentication (email as username)
- JWT tokens for session management
- Password requirements: minimum 8 characters, complexity rules (except initial admin seed)
- Initial admin user: `admin@example.com` / `0000` (created via seed script)
- Auth state restored from localStorage on app initialization (checkAuth action)

**Authorization**:
- Role-based access control (RBAC): ADMIN and USER roles
- Default to least privilege
- Route guards enforce role requirements
- Users can update own password with current password verification

## Important Constraints

### Technical Constraints

**Scale & Performance**:
- Support up to 100 total users across all subscriptions
- Support up to 20 users per individual subscription
- Response time: < 2 seconds under normal load
- Uptime: 99% during business hours (8 AM - 8 PM local time)

**Infrastructure**:
- Simple ECS with public IP (no ALB) for direct access
- Public RDS access for maximum simplicity
- Basic security groups with HTTPS only
- Minimal monitoring with application-level logging
- Stop-and-start deployments with brief downtime acceptable

**Database**:
- PostgreSQL everywhere (development and production)
- Docker Compose for local development
- AWS RDS for production
- Automated backups via RDS snapshots
- Point-in-time recovery supported

**State Management**:
- No NgRx state persistence (security requirement for financial data)
- State recreated on page refresh
- Authentication state stored in localStorage (JWT token)

### Business Constraints

**Data Retention**:
- Financial data retained minimum 1 year
- Secure data deletion capabilities for users who leave

**Concurrent Access**:
- Last-write-wins semantics without user notification of conflicts
- Ensures data consistency without complex conflict resolution

**Security**:
- HTTPS enforced in all environments (CloudFront/ALB termination)
- Passwords hashed with bcrypt
- No plaintext secrets in code
- Rate limiting on API endpoints
- CSRF protection if cookies used for auth
- Audit logs for critical actions (payment verification, user/admin changes)

### Development Constraints

**Code Quality**:
- All tests and linters must pass in CI
- Failing pipelines block merges
- Minimum 80% test coverage required

**Documentation**:
- API contracts in OpenAPI format
- Spec files for each feature
- Quickstart guides for setup
- Terraform documentation for infrastructure

**Change Management**:
- All changes via PR with approval required
- Constitution compliance checked in feature plans
- Spec updates required for behavior/config changes

## External Dependencies

### AWS Services
- **ECS Fargate**: Container hosting for backend application
- **S3**: Static asset storage for frontend
- **CloudFront**: CDN and HTTPS termination for frontend
- **RDS PostgreSQL**: Managed database service for production
- **VPC**: Virtual private cloud for network isolation
- **CloudWatch**: Logging and basic monitoring
- **ECR**: Container registry for Docker images

### Third-Party Services
- **GitHub**: Source code repository and CI/CD (GitHub Actions)
- **Docker Hub**: Base images (node:18-alpine, postgres:15, redis:7-alpine)

### Development Dependencies
- **Prisma**: Database ORM and migration tool
- **Docker & Docker Compose**: Local development environment
- **Terraform**: Infrastructure provisioning and management

### API Contracts
- OpenAPI specifications in `specs/*/contracts/` directories
- API documentation available at `/api/docs` when backend running
