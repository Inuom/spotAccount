name: CI/CD Pipeline

on:
  push:
    branches: [master, develop]
  pull_request:
    branches: [master, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to test"
        required: true
        default: "production"
        type: choice
        options:
          - production

env:
  NODE_VERSION: "18"
  AWS_REGION: "eu-west-1"
  ECR_BACKEND_REPOSITORY: "spotaccount-backend"
  ECR_FRONTEND_REPOSITORY: "spotaccount-frontend"
  ECS_CLUSTER: "spotaccount-cluster"
  ECS_SERVICE: "spotaccount-service"
  TERRAFORM_VERSION: "1.6.0"

jobs:
  test:
    name: Test and Quality Checks
    if: false
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run backend tests
        run: |
          cd backend
          npm run test:cov
        env:
          DATABASE_URL: "postgresql://test:test@localhost:5432/test"
          JWT_SECRET: "test-jwt-secret"
          NODE_ENV: "test"

      - name: Run backend type checking
        run: |
          cd backend
          npm run build

      - name: Run frontend type checking
        run: |
          cd frontend
          npm run build

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test
    if: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Build backend
        run: |
          cd backend
          npm run build

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Upload backend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: backend-build
          path: backend/dist/

      - name: Upload frontend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/dist/

  docker:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: build
    if: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download backend build artifacts
        uses: actions/download-artifact@v4
        with:
          name: backend-build
          path: backend/dist/

      - name: Download frontend build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: frontend/dist/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend Docker image
        run: |
          cd backend
          docker build -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPOSITORY }}:$GITHUB_SHA .
          docker push $ECR_REGISTRY/${{ env.ECR_BACKEND_REPOSITORY }}:$GITHUB_SHA
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

      - name: Build and push frontend Docker image
        run: |
          cd frontend
          docker build -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPOSITORY }}:$GITHUB_SHA .
          docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPOSITORY }}:$GITHUB_SHA
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    #needs: [test, build, docker]
    if: github.ref == 'refs/heads/master'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      - name: Terraform Init
        env:
          TF_VAR_project_name: "spotaccount"
          TF_VAR_environment: "production"
          TF_VAR_aws_region: "eu-west-1"
          TF_VAR_vpc_cidr: "10.0.0.0/16"
          TF_VAR_ecs_cluster_name: "spotaccount-cluster"
          TF_VAR_ecs_service_name: "spotaccount-service"
          TF_VAR_ecs_task_cpu: "256"
          TF_VAR_ecs_task_memory: "512"
          TF_VAR_ecs_desired_count: "1"
          TF_VAR_db_instance_class: "db.t3.micro"
          TF_VAR_db_allocated_storage: "20"
          TF_VAR_db_max_allocated_storage: "100"
          TF_VAR_db_backup_retention_period: "7"
          TF_VAR_db_backup_window: "03:00-04:00"
          TF_VAR_db_maintenance_window: "sun:04:00-sun:05:00"
          TF_VAR_db_password: ${{ secrets.DATABASE_PASSWORD }}
          TF_VAR_cloudfront_price_class: "PriceClass_100"
          TF_VAR_app_port: "3000"
          TF_VAR_app_health_check_path: "/healthz"
          TF_VAR_database_password: ${{ secrets.DATABASE_PASSWORD }}
        run: |
          cd infrastructure/terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_BACKEND_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TERRAFORM_BACKEND_DYNAMODB_TABLE }}"

      - name: Terraform Plan
        run: |
          cd infrastructure/terraform
          terraform plan 

      - name: Terraform Apply
        run: |
          cd infrastructure/terraform
          terraform apply -auto-approve 

      - name: Deploy application to ECS
        run: |
          # Update ECS service with new task definition
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment

      - name: Wait for deployment to complete
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}

      - name: Health check
        run: |
          # Get ALB DNS name from Terraform output
          ALB_DNS=$(cd infrastructure/terraform && terraform output -raw alb_dns_name)
          curl -f http://$ALB_DNS/healthz || exit 1
