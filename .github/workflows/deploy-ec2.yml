name: EC2 Production Deployment

# Feature: simplify-aws-to-ec2
# Simplified deployment workflow for EC2 instance

on:
  push:
    branches: [master]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: 'eu-west-1'
  NODE_VERSION: '18'
  ECR_BACKEND_REPOSITORY: 'spotaccount-backend'
  ECR_FRONTEND_REPOSITORY: 'spotaccount-frontend'
  EC2_USER: 'ec2-user'
  EC2_APP_DIR: '/opt/spotaccount'

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    
    outputs:
      backend_image: ${{ steps.image-tags.outputs.backend_image }}
      frontend_image: ${{ steps.image-tags.outputs.frontend_image }}
      image_tag: ${{ steps.image-tags.outputs.tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Generate image tags
      id: image-tags
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        IMAGE_TAG="${GITHUB_SHA:0:8}-$(date +%Y%m%d%H%M%S)"
        echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "backend_image=$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "frontend_image=$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "### Image Tags" >> $GITHUB_STEP_SUMMARY
        echo "- Backend: \`$ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
        echo "- Frontend: \`$ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: |
          backend/package-lock.json
          frontend/package-lock.json
        
    - name: Build backend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.image-tags.outputs.tag }}
      run: |
        cd backend
        docker build \
          --tag $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG \
          --tag $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest \
          --build-arg NODE_ENV=production \
          .
        
    - name: Build frontend
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.image-tags.outputs.tag }}
      run: |
        cd frontend
        docker build \
          --tag $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG \
          --tag $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest \
          --build-arg NODE_ENV=production \
          .
        
    - name: Push images to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.image-tags.outputs.tag }}
      run: |
        docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_BACKEND_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_FRONTEND_REPOSITORY:latest
        echo "✅ Images pushed successfully" >> $GITHUB_STEP_SUMMARY

  deploy-to-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get EC2 instance details
      id: ec2-info
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=spotaccount-production-ec2" "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].InstanceId' \
          --output text)
        
        if [ "$INSTANCE_ID" == "None" ] || [ -z "$INSTANCE_ID" ]; then
          echo "❌ EC2 instance not found or not running" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_ID \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text)
        
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
        echo "### EC2 Instance" >> $GITHUB_STEP_SUMMARY
        echo "- Instance ID: \`$INSTANCE_ID\`" >> $GITHUB_STEP_SUMMARY
        echo "- Public IP: \`$PUBLIC_IP\`" >> $GITHUB_STEP_SUMMARY
        
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Write SSH private key with proper formatting
        # Remove any leading/trailing whitespace and ensure proper line endings
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key
        
        # Add EC2 host to known_hosts to avoid interactive prompt
        ssh-keyscan -H ${{ steps.ec2-info.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true
        chmod 644 ~/.ssh/known_hosts
        
        # Verify SSH key format
        if ! ssh-keygen -l -f ~/.ssh/ec2_key > /dev/null 2>&1; then
          echo "❌ Invalid SSH key format" >> $GITHUB_STEP_SUMMARY
          echo "Please check that EC2_SSH_PRIVATE_KEY secret contains a valid private key" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        # Extract and display public key fingerprint for verification
        KEY_FINGERPRINT=$(ssh-keygen -l -f ~/.ssh/ec2_key | awk '{print $2}')
        echo "### SSH Key Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Key Type**: ED25519" >> $GITHUB_STEP_SUMMARY
        echo "- **Fingerprint**: \`$KEY_FINGERPRINT\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**⚠️ IMPORTANT**: This public key must be in \`~/.ssh/authorized_keys\` on EC2:" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        ssh-keygen -y -f ~/.ssh/ec2_key >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        
        echo "✅ SSH key configured successfully" >> $GITHUB_STEP_SUMMARY
        
    - name: Test SSH connection
      env:
        EC2_HOST: ${{ steps.ec2-info.outputs.public_ip }}
      run: |
        echo "Testing SSH connection to $EC2_USER@$EC2_HOST..."
        
        # Test SSH connection with verbose output for debugging
        if ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 -v $EC2_USER@$EC2_HOST "echo 'SSH connection successful'" 2>&1; then
          echo "✅ SSH connection test passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ SSH connection test failed" >> $GITHUB_STEP_SUMMARY
          echo "Please verify:" >> $GITHUB_STEP_SUMMARY
          echo "1. EC2_SSH_PRIVATE_KEY secret is correctly set in GitHub Secrets" >> $GITHUB_STEP_SUMMARY
          echo "2. The corresponding public key is in ~/.ssh/authorized_keys on the EC2 instance" >> $GITHUB_STEP_SUMMARY
          echo "3. Security group allows SSH (port 22) from GitHub Actions IPs" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
    - name: Copy deployment files to EC2
      env:
        EC2_HOST: ${{ steps.ec2-info.outputs.public_ip }}
      run: |
        echo "Copying deployment files to EC2..."
        
        # Ensure target directories exist on EC2
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST \
          "mkdir -p $EC2_APP_DIR/scripts $EC2_APP_DIR/nginx"
        
        # Copy docker-compose configuration
        scp -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no \
          docker-compose.prod.yml $EC2_USER@$EC2_HOST:$EC2_APP_DIR/ || {
          echo "❌ Failed to copy docker-compose.prod.yml" >> $GITHUB_STEP_SUMMARY
          exit 1
        }
        
        # Copy nginx configuration
        scp -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no -r \
          nginx $EC2_USER@$EC2_HOST:$EC2_APP_DIR/ || {
          echo "❌ Failed to copy nginx configuration" >> $GITHUB_STEP_SUMMARY
          exit 1
        }
        
        # Copy deployment script
        scp -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no \
          scripts/deploy-ec2.sh $EC2_USER@$EC2_HOST:$EC2_APP_DIR/scripts/ || {
          echo "❌ Failed to copy deployment script" >> $GITHUB_STEP_SUMMARY
          exit 1
        }
        
        # Make deployment script executable
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST \
          "chmod +x $EC2_APP_DIR/scripts/deploy-ec2.sh" || {
          echo "⚠️ Failed to make script executable (non-critical)" >> $GITHUB_STEP_SUMMARY
        }
        
        echo "✅ Deployment files copied successfully" >> $GITHUB_STEP_SUMMARY
        
    - name: Update environment variables on EC2
      env:
        EC2_HOST: ${{ steps.ec2-info.outputs.public_ip }}
        BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
        FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}
      run: |
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST << 'EOF'
        cd ${{ env.EC2_APP_DIR }}
        
        # Update image tags in environment file
        sed -i "s|BACKEND_IMAGE=.*|BACKEND_IMAGE=${{ env.BACKEND_IMAGE }}|" .env.production
        sed -i "s|FRONTEND_IMAGE=.*|FRONTEND_IMAGE=${{ env.FRONTEND_IMAGE }}|" .env.production
        
        echo "✅ Environment variables updated"
        EOF
        
    - name: Deploy application on EC2
      env:
        EC2_HOST: ${{ steps.ec2-info.outputs.public_ip }}
      run: |
        ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST << 'EOF'
        cd ${{ env.EC2_APP_DIR }}
        
        # Run deployment script
        bash scripts/deploy-ec2.sh
        EOF
        
    - name: Verify deployment
      env:
        EC2_HOST: ${{ steps.ec2-info.outputs.public_ip }}
      run: |
        # Wait a bit for services to start
        sleep 10
        
        # Check health endpoint via nginx
        MAX_ATTEMPTS=30
        ATTEMPT=0
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          # Try via nginx (port 80) - nginx proxies /healthz to backend /api/health/healthz
          if curl -f -s --max-time 5 http://$EC2_HOST/healthz > /dev/null 2>&1; then
            echo "✅ Health check passed via nginx" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          # Fallback: try direct backend access via SSH if nginx not ready
          # Uncomment below if you want to check backend directly when nginx is not ready
          # if [ $ATTEMPT -gt 5 ]; then
          #   if ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no -o ConnectTimeout=5 $EC2_USER@$EC2_HOST \
          #     "docker exec spotaccount-backend wget --quiet --tries=1 --spider http://localhost:3000/api/health/healthz" 2>/dev/null; then
          #     echo "✅ Health check passed (backend direct, nginx starting)" >> $GITHUB_STEP_SUMMARY
          #     exit 0
          #   fi
          # fi
          ATTEMPT=$((ATTEMPT+1))
          sleep 2
        done
        
        echo "❌ Health check failed after $MAX_ATTEMPTS attempts" >> $GITHUB_STEP_SUMMARY
        # Uncomment below to show container status on failure
        # echo "Checking container status..." >> $GITHUB_STEP_SUMMARY
        # ssh -i ~/.ssh/ec2_key -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST \
        #   "docker ps -a" >> $GITHUB_STEP_SUMMARY || true
        exit 1
        
    - name: Cleanup
      if: always()
      run: |
        rm -f ~/.ssh/ec2_key

  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-ec2]
    if: always()
    
    steps:
    - name: Deployment summary
      run: |
        if [ "${{ needs.deploy-to-ec2.result }}" == "success" ]; then
          echo "## ✅ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Actor**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend Image**: ${{ needs.build-and-push.outputs.backend_image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend Image**: ${{ needs.build-and-push.outputs.frontend_image }}" >> $GITHUB_STEP_SUMMARY
        else
          echo "## ❌ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please check the logs for details." >> $GITHUB_STEP_SUMMARY
        fi

